MAVEN,GRADLE LIBRARY LIFECYCLE

{https://windosakacastle.tistory.com/12?category=691705
(AWS사용하여 SPRING PROJECT 배포하기)}

{bulid.gradle 프로젝트 설명 파일}

MVC PATTERN {
MODEL : 앱이 포함해야할 데이터의 정의
VIEW : 데이터를 보여주는 방식
CONTROLLER : 앱의 사용자로부터 입력에 대한 응답으로 로직을 포함.
}

TEMPLATE ENGINE{
VIEW의 동적인 처리를 위한 것.
정적인 HTML파일을 사용자에게 보여주는 것이 아닌
동적으로 변하는 데이터를 화면에 보여주기 위한 개념.
}

ANNOTATION {
메타데이터(자신의 정보를 담고 있는 데이터)로써의 역할이 있다.
프로그램 실행과정에서 데이터를 어떻게 처리할 것인지 알려주는 서브데이터라고 볼 수 있다.
}

{spring은 apache tomcat을 기본적으로 내장하고 있어서
별도의 설치가 필요없다.}

apache ,tomcat 차이 {
아파치는 HTML,CSS와 같은 정적타입의 데이터만 처리,
톰캣은 DB,로직 처리등 동적타입의 데이터를 처리
}

번외 {
preferences(MAC) settings(WINDOWS) -> GRADLE을 검색해서
Build and run 을 다 IntelliJ 로 바꾸어준다.
이렇게하지않으면 GRADLE을 통해서 실행을 하기 때문에 
실행속도가 조금 느릴 수 있다.
}

GRADLE,MAVEN {
일종의 BUILD TOOL이다.
라이브러리간의 의존 관계를 관리해준다.
네트워크를 통해 라이브러리를 관리해주는 도구.
}

EMBADED

LOG{
실무에선 system.out.println 메서드를 사용하지 않는다.
로그파일들을 관리하기 위해 로그를 더 많이 사용한다.
slf4j,logback
}

STATIC{
변하지 않는, 움직이지 않는, 정적인 요소
}

SPRING , SPRING BOOT 이야기 {
스프링은 자바엔터프라이즈 웹애플리케이션개발과 관련된
전반의 생태계를 다 제공해준다.
스프링부트는 스프링을 좀 더 편리하게 사용해주기 위해 만들어진 FRAME WORK
}

WELCOME PAGE {
static 폴더에서 index.html을 제일 먼저 찾는다.
WEB-APP의 첫 진입점은 CONTROLLER이다.
controller가 될 자바 클래스는 @Controller 와 같이
어노테이션을 선언해주어야 한다.
@GetMapping은 괄호안의 문자열을 url과 매핑한다.
컨트롤러에서 리턴 값으로 문자를 반환하면 viewResolver가 문자열과 일치하는 html파일을 찾아서 처리한다.
}

BUILD해서 JAR파일 실행시키기{
명령프롬프트에서 프로젝트 폴더로 이동,
gradlew build 명령어를 통해 build하기
build-libs 폴더로 이동 후 
java -jar (jar파일명).jar 로 실행
}

API {
@ResponseBody 어노테이션을 사용하면
리턴하는 값을 그대로 http body에 표시한다.
근데 리턴하는값이 객체일 경우 viewResolver가 아닌
HttpMessageConverter가 동작하고 그 안에 있는
JsonConverter가 동작하여
객체가 json형식으로 표현된다.
}

동시성문제,공유되는 변수

long,Long{
원시타입은 성능과 메모리에 장점이 있다.
Null을 다뤄야 하거나 제네릭 타입에서 사용되어야 한다면
참조 타입을 사용한다.
}

TEST CASE {
개발한 기능을 테스트하기 위해 기능을 JUnit이라는 프레임워크를 이용하여 테스트 실행을 한다.
}

회원 도메인과 리포지토리 만들기 {
alt + insert를 누르면 constructor , getter,setter 등을 생성 할 수 있다.
Optional은 JAVA8에 추가 된 클래스이다.
null에 대한 처리때문에 사용한다.
alt + enter 를 누르면 인터페이스의 메소드들을 불러올 수 있다.
ctrl + space는 import를 할 수 있다.
Member 정보를 저장 할 수 있게 Member 클래스를 만들어주고
Repository 객체를 생성 후 Hashmap을 생성하고
거기에 Member객체를 파라미터로 받는 메서드를 작성 후
메서드안에서 Hashmap에 id값과 파라미터로 받은 member객체를 put해준다.
}

스프링 빈과 의존관계{
스프링은 실행될때 스프링 컨테이너가 생기는데
Controller 어노테이션을 찾아서
그 객체를 미리 생성해두고 관리한다.
이것을 스프링 빈을 관리한다고 표현한다.
컨트롤러에서 객체를 사용할때에는 new 생성자를 사용하기보단
@Autowired 어노테이션을 이용해서 객체의 constructor를 사용하는게 스프링컨테이너 특성상 이점이 많다.
그런데 컨트롤러에서 자바클래스를 사용하려고 할때
스프링에서는 순수한자바언어를 읽을 수 없다.
그래서 서비스객체에 @Service라는 어노테이션을 달아주어야 한다.
그래야 스프링컨테이너에서 서비스어노테이션을 찾을 수 있기 때문이다.
Repository도 마찬가지로 @Repository 어노테이션을 달아주어야 한다.
이렇게 컨트롤러와 서비스를 연결시켜주어야 하는데
컨트롤러가 생성될 때 스프링빈에 등록되어있는 멤버서비스 객체를 찾아서 넣어준다.
그리고 Autowired어노테이션을 또 찾아서 그 생성자에 필요한 다른 객체를 또 찾아서 컨테이너에 넣어준다.
이것이 DI(Dependency Injection)의존성 주입이다.
스프링 빈을 등록하는 2가지 방법이 있다.
@Controller @Service 등 어노테이션을 달아주는 것이
컴포넌트 스캔 방식이다.
이 어노테이션들은 @Component라는 어노테이션이 달려있는데
스프링이 실행될때 @Component에 관련된 어노테이션이 있으면 하나씩 객체를 생성해서 컨테이너에 등록한다.
그리고 Autowired는 객체들 간의 연관관계이다.
이것이 컴포넌트스캔과 자동 의존관계 설정이고
나머지 하나의 방법은 자바코드로 직접 스프링 빈 등록하기이다.
}

자바코드로 직접 스프링 빈 등록하기{
클래스를 따로 만들어서
@Configuration 어노테이션을 클래스위에 달아준다.
그리고 @Bean 어노테이션을 사용해 객체를 생성해주는 메소드를 작성한다.
DI에는 필드주입,SETTER주입,생성자주입 3가지 방법이 있다.
의존관계가 실행중에 동적으로 변하는 경우는 거의 없으므로 생성자 주입을 권장한다.
실무에선 주로 정형화된 컨트롤러,서비스,리포지토리 같은 코드는
컴포넌트 스캔을 사용한다고 한다.
그리고 정형화되지 않거나 상황에 따라 구현 클래스를 변경해야 하면 설정을 통해 스프링 빈으로 등록한다.
}

